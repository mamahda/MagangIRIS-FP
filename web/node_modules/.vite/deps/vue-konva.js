import {
  require_lib
} from "./chunk-ZXYQXIFG.js";
import {
  defineComponent,
  getCurrentInstance,
  h,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  onUpdated,
  reactive,
  ref,
  watch
} from "./chunk-DB4KVPJ4.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/vue-konva/dist/vue-konva.mjs
var import_konva = __toESM(require_lib(), 1);
function _(a) {
  if (!import_konva.default.autoDrawEnabled) {
    const o = a.getLayer() || a.getStage();
    o && o.batchDraw();
  }
}
var m = { key: true, style: true, elm: true, isRootInsert: true };
var N = ".vue-konva-event";
function T(a, o, n, c) {
  const e = a.__konvaNode, i = {};
  let t = false;
  for (let r in n) {
    if (m.hasOwnProperty(r))
      continue;
    const d = r.slice(0, 2) === "on", v = n[r] !== o[r];
    if (d && v) {
      let s = r.slice(2).toLowerCase();
      s.slice(0, 7) === "content" && (s = "content" + s.slice(7, 1).toUpperCase() + s.slice(8)), e == null || e.off(s + N, n[r]);
    }
    !o.hasOwnProperty(r) && (e == null || e.setAttr(r, void 0));
  }
  for (let r in o) {
    if (m.hasOwnProperty(r))
      continue;
    let d = r.slice(0, 2) === "on";
    const v = n[r] !== o[r];
    if (d && v) {
      let f = r.slice(2).toLowerCase();
      f.slice(0, 7) === "content" && (f = "content" + f.slice(7, 1).toUpperCase() + f.slice(8)), o[r] && (e == null || e.off(f + N), e == null || e.on(f + N, o[r]));
    }
    !d && (o[r] !== n[r] || c && o[r] !== (e == null ? void 0 : e.getAttr(r))) && (t = true, i[r] = o[r]);
  }
  t && e && (e.setAttrs(i), _(e));
}
var R = "v";
function M(a) {
  function o(n) {
    return n != null && n.__konvaNode ? n : n != null && n.parent ? o(n.parent) : (console.error("vue-konva error: Can not find parent node"), null);
  }
  return o(a.parent);
}
function L(a) {
  return a.component ? a.component.__konvaNode || L(a.component.subTree) : null;
}
function I(a) {
  const { el: o, component: n } = a, c = L(a);
  if (o != null && o.tagName && n && !c) {
    const e = o.tagName.toLowerCase();
    return console.error(
      `vue-konva error: You are trying to render "${e}" inside your component tree. Looks like it is not a Konva node. You can render only Konva components inside the Stage.`
    ), null;
  }
  return c;
}
function U(a) {
  const o = (e) => !!(e != null && e.hasOwnProperty("component")), n = (e) => Array.isArray(e), c = (e) => o(e) ? [e, ...c(e.children)] : n(e) ? e.flatMap(c) : [];
  return c(a.children);
}
function b(a, o) {
  const n = U(a), c = [];
  n.forEach((i) => {
    const t = I(i);
    t && c.push(t);
  });
  let e = false;
  c.forEach((i, t) => {
    i.getZIndex() !== t && (i.setZIndex(t), e = true);
  }), e && _(o);
}
var j = defineComponent({
  name: "Stage",
  props: {
    config: {
      type: Object,
      default: function() {
        return {};
      }
    },
    __useStrictMode: {
      type: Boolean
    }
  },
  inheritAttrs: false,
  setup(a, { attrs: o, slots: n, expose: c }) {
    const e = getCurrentInstance();
    if (!e) return;
    const i = reactive({}), t = ref(null), r = new import_konva.default.Stage({
      width: a.config.width,
      height: a.config.height,
      container: document.createElement("div")
      // Fake container. Will be replaced
    });
    e.__konvaNode = r, f();
    function d() {
      return e == null ? void 0 : e.__konvaNode;
    }
    function v() {
      return e == null ? void 0 : e.__konvaNode;
    }
    function f() {
      if (!e) return;
      const s = i || {}, g = {
        ...o,
        ...a.config
      };
      T(e, g, s, a.__useStrictMode), Object.assign(i, g);
    }
    return onMounted(() => {
      t.value && (t.value.innerHTML = "", r.container(t.value)), f();
    }), onUpdated(() => {
      f(), b(e.subTree, r);
    }), onBeforeUnmount(() => {
      r.destroy();
    }), watch(() => a.config, f, { deep: true }), c({
      getStage: v,
      getNode: d
    }), () => {
      var s;
      return h("div", { ref: t }, (s = n.default) == null ? void 0 : s.call(n));
    };
  }
});
var V = ".vue-konva-event";
var F = {
  Group: true,
  Layer: true,
  FastLayer: true,
  Label: true
};
function G(a, o) {
  return defineComponent({
    name: a,
    props: {
      config: {
        type: Object,
        default: function() {
          return {};
        }
      },
      __useStrictMode: {
        type: Boolean
      }
    },
    setup(n, { attrs: c, slots: e, expose: i }) {
      const t = getCurrentInstance();
      if (!t) return;
      const r = reactive({}), d = new o();
      t.__konvaNode = d, t.vnode.__konvaNode = d, s();
      function v() {
        return t == null ? void 0 : t.__konvaNode;
      }
      function f() {
        return t == null ? void 0 : t.__konvaNode;
      }
      function s() {
        if (!t) return;
        const l = {};
        for (const h2 in t == null ? void 0 : t.vnode.props)
          h2.slice(0, 2) === "on" && (l[h2] = t.vnode.props[h2]);
        const p = r || {}, y = {
          ...c,
          ...n.config,
          ...l
        };
        T(t, y, p, n.__useStrictMode), Object.assign(r, y);
      }
      onMounted(() => {
        var p;
        const l = (p = M(t)) == null ? void 0 : p.__konvaNode;
        l && "add" in l && l.add(d), _(d);
      }), onUnmounted(() => {
        _(d), d.destroy(), d.off(V);
      }), onUpdated(() => {
        s(), b(t.subTree, d);
      }), watch(() => n.config, s, { deep: true }), i({
        getStage: f,
        getNode: v
      });
      const g = F.hasOwnProperty(a);
      return () => {
        var l;
        return g ? h("template", {}, (l = e.default) == null ? void 0 : l.call(e)) : null;
      };
    }
  });
}
typeof window < "u" && !window.Konva && require_lib();
var D = {
  install: (a, o) => {
    const n = (o == null ? void 0 : o.prefix) || R, c = {
      Arc: import_konva.default.Arc,
      Arrow: import_konva.default.Arrow,
      Circle: import_konva.default.Circle,
      Ellipse: import_konva.default.Ellipse,
      FastLayer: import_konva.default.FastLayer,
      Group: import_konva.default.Group,
      Image: import_konva.default.Image,
      Label: import_konva.default.Label,
      Layer: import_konva.default.Layer,
      Line: import_konva.default.Line,
      Path: import_konva.default.Path,
      Rect: import_konva.default.Rect,
      RegularPolygon: import_konva.default.RegularPolygon,
      Ring: import_konva.default.Ring,
      Shape: import_konva.default.Shape,
      Sprite: import_konva.default.Sprite,
      Star: import_konva.default.Star,
      Tag: import_konva.default.Tag,
      Text: import_konva.default.Text,
      TextPath: import_konva.default.TextPath,
      Transformer: import_konva.default.Transformer,
      Wedge: import_konva.default.Wedge,
      ...o == null ? void 0 : o.customNodes
    };
    [
      j,
      ...Object.entries(c).map(
        ([i, t]) => G(i, t)
      )
    ].forEach((i) => {
      a.component(`${n}${i.name}`, i);
    });
  }
};
export {
  D as default
};
//# sourceMappingURL=vue-konva.js.map
